// -------------------------------------------------------------
//
// Module: iirElliptic1623
// Generated by MATLAB(R) 23.2 and Filter Design HDL Coder 23.2.
// Generated on: 2023-12-05 13:13:04
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// Name: iirElliptic1623
// TargetLanguage: Verilog
// TestBenchName: iirElliptic1623_tb
// TestBenchStimulus: step ramp chirp 
// GenerateHDLTestBench: off

// Filter Specifications:
//
// Sample Rate   : 48 kHz
// Response      : Lowpass
// Specification : N,Fp,Fst
// Stopband Edge : 23 kHz
// Filter Order  : 2
// Passband Edge : 16 kHz
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// Folding Factor        : 1
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time IIR Filter (real)
// -------------------------------
// Filter Structure    : Direct-Form II, Second-Order Sections
// Number of Sections  : 1
// Stable              : Yes
// Linear Phase        : No
// Arithmetic          : fixed
// Numerator           : u16,14 -> [0 4)
// Denominator         : u16,15 -> [0 2)
// Scale Values        : u16,15 -> [0 2)
// Input               : s9,0 -> [-256 256)
// Section Input       : s16,-5 -> [-1048576 1048576)
// Section Output      : s16,-4 -> [-524288 524288)
// Output              : s13,-7 -> [-524288 524288)
// State               : s16,0 -> [-32768 32768)
// Numerator Prod      : s32,14 -> [-131072 131072)
// Denominator Prod    : s32,15 -> [-65536 65536)
// Numerator Accum     : s40,14 -> [-33554432 33554432)
// Denominator Accum   : s40,15 -> [-16777216 16777216)
// Round Mode          : convergent
// Overflow Mode       : wrap
// Cast Before Sum     : true
// -------------------------------------------------------------




`timescale 1 ns / 1 ns

module iirElliptic1623
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   signed [8:0] filter_in; //sfix9
  output  signed [12:0] filter_out; //sfix13_E7

////////////////////////////////////////////////////////////////
//Module Architecture: iirElliptic1623
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter scaleconst1 = 16'b0010110001111011; //ufix16_En15
  parameter coeff_b1_section1 = 16'b0100000001001010; //ufix16_En14
  parameter coeff_b2_section1 = 16'b1000000000000000; //ufix16_En14
  parameter coeff_b3_section1 = 16'b0100000001000011; //ufix16_En14
  parameter coeff_a2_section1 = 16'b1000010010000001; //ufix16_En15
  parameter coeff_a3_section1 = 16'b0011010010010100; //ufix16_En15
  parameter scaleconst2 = 16'b1101110110101111; //ufix16_En15
  // Signals
  reg  signed [8:0] input_register; // sfix9
  wire signed [35:0] scale1; // sfix36_En15
  wire signed [25:0] mul_temp; // sfix26_En15
  wire signed [15:0] scaletypeconvert1; // sfix16_E5
  // Section 1 Signals 
  wire signed [39:0] a1sum1; // sfix40_En15
  wire signed [39:0] a2sum1; // sfix40_En15
  wire signed [39:0] b1sum1; // sfix40_En14
  wire signed [39:0] b2sum1; // sfix40_En14
  wire [15:0] typeconvert1; // ufix16
  reg  [15:0] delay_section1 [0:1] ; // ufix16
  wire signed [39:0] inputconv1; // sfix40_En15
  wire signed [31:0] a2mul1; // sfix32_En15
  wire signed [31:0] a3mul1; // sfix32_En15
  wire signed [31:0] b1mul1; // sfix32_En14
  wire signed [31:0] b2mul1; // sfix32_En14
  wire signed [31:0] b3mul1; // sfix32_En14
  wire [31:0] mul_temp_1; // ufix32_En15
  wire [31:0] mul_temp_2; // ufix32_En15
  wire [31:0] mul_temp_3; // ufix32_En14
  wire [31:0] mul_temp_4; // ufix32_En14
  wire signed [39:0] sub_cast; // sfix40_En15
  wire signed [39:0] sub_cast_1; // sfix40_En15
  wire signed [40:0] sub_temp; // sfix41_En15
  wire signed [39:0] sub_cast_2; // sfix40_En15
  wire signed [39:0] sub_cast_3; // sfix40_En15
  wire signed [40:0] sub_temp_1; // sfix41_En15
  wire signed [39:0] b1multypeconvert1; // sfix40_En14
  wire signed [39:0] add_cast; // sfix40_En14
  wire signed [39:0] add_cast_1; // sfix40_En14
  wire signed [40:0] add_temp; // sfix41_En14
  wire signed [39:0] add_cast_2; // sfix40_En14
  wire signed [39:0] add_cast_3; // sfix40_En14
  wire signed [40:0] add_temp_1; // sfix41_En14
  wire signed [15:0] section_result1; // sfix16_E4
  wire signed [35:0] scale2; // sfix36_En15
  wire signed [32:0] mul_temp_5; // sfix33_En11
  wire signed [12:0] output_typeconvert; // sfix13_E7
  reg  signed [12:0] output_register; // sfix13_E7

  // Block Statements
  always @ (posedge clk or posedge reset)
    begin: input_reg_process
      if (reset == 1'b1) begin
        input_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          input_register <= filter_in;
        end
      end
    end // input_reg_process

  assign mul_temp = input_register * $signed({1'b0, scaleconst1});
  assign scale1 = $signed({{10{mul_temp[25]}}, mul_temp});

  assign scaletypeconvert1 = (scale1[35:0] + {scale1[20], {19{~scale1[20]}}})>>>20;

  //   ------------------ Section 1 ------------------

  assign typeconvert1 = $unsigned(($unsigned(a1sum1[30:0]) + {a1sum1[15], {14{~a1sum1[15]}}})>>>15);

  always @ (posedge clk or posedge reset)
    begin: delay_process_section1
      if (reset == 1'b1) begin
        delay_section1[0] <= 16'b0000000000000000;
        delay_section1[1] <= 16'b0000000000000000;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section1[1] <= delay_section1[0];
          delay_section1[0] <= typeconvert1;
        end
      end
    end // delay_process_section1

  assign inputconv1 = $signed({scaletypeconvert1[15:0], 20'b00000000000000000000});

  assign mul_temp_1 = delay_section1[0] * coeff_a2_section1;
  assign a2mul1 = $signed($signed(mul_temp_1));

  assign mul_temp_2 = delay_section1[1] * coeff_a3_section1;
  assign a3mul1 = $signed($signed(mul_temp_2));

  assign mul_temp_3 = typeconvert1 * coeff_b1_section1;
  assign b1mul1 = $signed($signed(mul_temp_3));

  assign b2mul1 = $signed({$signed(delay_section1[0][15:0]), 15'b000000000000000});

  assign mul_temp_4 = delay_section1[1] * coeff_b3_section1;
  assign b3mul1 = $signed($signed(mul_temp_4));

  assign sub_cast = inputconv1;
  assign sub_cast_1 = $signed({{8{a2mul1[31]}}, a2mul1});
  assign sub_temp = sub_cast - sub_cast_1;
  assign a2sum1 = sub_temp[39:0];

  assign sub_cast_2 = a2sum1;
  assign sub_cast_3 = $signed({{8{a3mul1[31]}}, a3mul1});
  assign sub_temp_1 = sub_cast_2 - sub_cast_3;
  assign a1sum1 = sub_temp_1[39:0];

  assign b1multypeconvert1 = $signed({{8{b1mul1[31]}}, b1mul1});

  assign add_cast = b1multypeconvert1;
  assign add_cast_1 = $signed({{8{b2mul1[31]}}, b2mul1});
  assign add_temp = add_cast + add_cast_1;
  assign b2sum1 = add_temp[39:0];

  assign add_cast_2 = b2sum1;
  assign add_cast_3 = $signed({{8{b3mul1[31]}}, b3mul1});
  assign add_temp_1 = add_cast_2 + add_cast_3;
  assign b1sum1 = add_temp_1[39:0];

  assign section_result1 = (b1sum1[33:0] + {b1sum1[18], {17{~b1sum1[18]}}})>>>18;

  assign mul_temp_5 = section_result1 * $signed({1'b0, scaleconst2});
  assign scale2 = $signed({mul_temp_5[31:0], 4'b0000});

  assign output_typeconvert = (scale2[34:0] + {scale2[22], {21{~scale2[22]}}})>>>22;

  always @ (posedge clk or posedge reset)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign filter_out = output_register;
endmodule  // iirElliptic1623
